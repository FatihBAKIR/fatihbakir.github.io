<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://blog.fatihbakir.net/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.fatihbakir.net/" rel="alternate" type="text/html" /><updated>2019-05-17T23:11:57-07:00</updated><id>https://blog.fatihbakir.net/feed.xml</id><title type="html">Fatih’s blog</title><subtitle>Blog </subtitle><entry><title type="html">SSL considered harmful (in IoT)?</title><link href="https://blog.fatihbakir.net/2019/05/15/ssl-considered-harmful.html" rel="alternate" type="text/html" title="SSL considered harmful (in IoT)?" /><published>2019-05-15T00:00:00-07:00</published><updated>2019-05-15T00:00:00-07:00</updated><id>https://blog.fatihbakir.net/2019/05/15/ssl-considered-harmful</id><content type="html" xml:base="https://blog.fatihbakir.net/2019/05/15/ssl-considered-harmful.html">&lt;p&gt;I’ve been working on &lt;em&gt;Internet of Things&lt;/em&gt; research for over a year now. The bulk of it has been
working on getting cheap installations to work reliably and securely.&lt;/p&gt;

&lt;p&gt;It’s a known fact that security hasn’t been the top priority of IoT applications, whether it’s a
temperature sensor, a thermostat or a smart bulb. They get hacked, they become part of botnets,
and if nothing, they reduce your downtime.&lt;/p&gt;

&lt;p&gt;This is obviously not desirable. These things usually work over WiFi, so TCP/IP. So we should just 
slap our trusty SSL on top of it and call it a day, right?&lt;/p&gt;

&lt;p&gt;Nope. The main problem many people don’t see is what separates the &lt;em&gt;Internet of Things&lt;/em&gt; from the
regular internet. On the regular internet, we’ve mostly solved the security problems, and yes, the
solution is usually just encrypting the traffic. However, this solution just doesn’t scale &lt;em&gt;down&lt;/em&gt;
to tiny embedded systems that are now part of the same internet as our crazy back end servers. Here,
the devices are extremely constrained.&lt;/p&gt;

&lt;p&gt;Public key cryptography, which powers our security infrastructure on the internet, is not designed
to be run on processors with just a tens of megahertz clock speeds and a few KBs of RAM.&lt;/p&gt;

&lt;p&gt;No, they were designed for huge machines. A conforming, bidirectional SSL server &lt;strong&gt;must&lt;/strong&gt; be able
to keep about 33 kilobytes of buffers. The (relatively high end) microcontroller I’m using 
frequently only gives me about 48 kilobytes of RAM. So, if I wanted to run a full fledged SSL server
on it, I must waste two thirds of my RAM. Fortunately, you neither have to conform nor have to run
an SSL server on these things, so you can get away with about 5-10 KB of RAM for buffers.&lt;/p&gt;

&lt;p&gt;But no, I’m not finished yet. Then we get to the point of actually using these buffers in an actual
SSL session. Regardless of whether you are a server or a client, you have to perform the dreaded
SSL handshake. Boy, oh boy. It takes slightly more than 4KB of stack to execute that. If you’re 
smart and looking for some adventure, you can probably use that wasted memory after the handshake
for some other purposes, but otherwise, it’ll just lay there after the handshake.&lt;/p&gt;

&lt;p&gt;Oh, there’s also the issue of runtime. A single SSL handshake, on 2048 bit RSA keys will take about
4 seconds on an ESP8266. And no, ECC doesn’t help too much either.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operation&lt;/th&gt;
      &lt;th&gt;Time&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;RSA Handshake (2048 Bit)&lt;/td&gt;
      &lt;td&gt;3,95 Seconds&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RSA Handshake (4096 Bit)&lt;/td&gt;
      &lt;td&gt;32,32 Seconds&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I’m not an expert on SSL, but my understanding is that the handshake is bottlenecked at digital
signature operations. Here are the numbers for those primitives as well:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Algorithm&lt;/th&gt;
      &lt;th&gt;Sign Time&lt;/th&gt;
      &lt;th&gt;Verify Time&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;PKCS1 (2048 Bits)&lt;/td&gt;
      &lt;td&gt;3280 ms&lt;/td&gt;
      &lt;td&gt;187 ms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PKCS1 (4096 Bits)&lt;/td&gt;
      &lt;td&gt;31580 ms&lt;/td&gt;
      &lt;td&gt;9190 ms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ECDSA (256 Bits)&lt;/td&gt;
      &lt;td&gt;214 ms&lt;/td&gt;
      &lt;td&gt;4340 ms&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Now, 4 seconds isn’t a huge amount of time. My sensors are duty cycled to do a measurement every 5
minutes and go to sleep. So, running for 4 more extra seconds shouldn’t hurt, right?&lt;/p&gt;

&lt;p&gt;The reason I’m going to sleep is to conserve power. We’re running on batteries here, and a regular
wake up-sample sensor-publish to cloud/edge-go back to sleep cycle takes about 2 seconds. Now, I just pay
twice that time just to do an SSL handshake. Oh, did I mention I’m on a WiFi network, which also has
encryption in the link layer. So, when I’m pushing to the edge, I probably don’t make use of the SSL
&lt;em&gt;at all&lt;/em&gt;. It’s pure overhead.&lt;/p&gt;

&lt;p&gt;Well, you might say that I don’t have to use SSL, so why complain this much. The reason is that every
single public cloud provider I’ve used (&lt;a class=&quot;citation&quot; href=&quot;#azure-mqtt-ssl&quot;&gt;[1]&lt;/a&gt;, &lt;a class=&quot;citation&quot; href=&quot;#aws-mqtt-ssl&quot;&gt;[2]&lt;/a&gt;, &lt;a class=&quot;citation&quot; href=&quot;#gc-mqtt-ssl&quot;&gt;[3]&lt;/a&gt;) 
expects me to publish only and only using SSL over MQTT.&lt;/p&gt;

&lt;p&gt;Now, it’s not their fault. Security in this domain is extremely important. However, maybe porting
everything we’re used to in the regular internet programming to these constrained devices isn’t
the greatest idea. SSL (thus public key encryption) is truly a marvellous technology, but it’s solving
a very specific problem: you want to verify each parties identity * encrypt the communication * don’t 
want to share a lot of keys ahead of time.&lt;/p&gt;

&lt;p&gt;For my commands to my thermostat, I don’t care a lot about the encryption. As long as I can verify
the authenticity of commands properly, an attacker cannot change my settings. Similarly for sensing
applications, if an attacker can’t inject random data to my public cloud database, I don’t really 
care about the data being encrypted, especially if I’m storing my data in an edge cloud where there
already exists a layer of security in link layer.&lt;/p&gt;

&lt;p&gt;Maybe it’s time to search for lighter security primitives that can scale down to the embedded systems
we have to use in this domain. As otherwise, we’ll either not do it properly, or not do it at all.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul class=&quot;bibliography&quot;&gt;&lt;li&gt;&lt;span id=&quot;azure-mqtt-ssl&quot;&gt;[1]“Azure IoT Hub communication protocols and ports | Microsoft Docs.” \urlhttps://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-protocols.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;aws-mqtt-ssl&quot;&gt;[2]“Protocols - AWS IoT.” \urlhttps://docs.aws.amazon.com/iot/latest/developerguide/protocols.html.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;gc-mqtt-ssl&quot;&gt;[3]“Publishing over the MQTT bridge  |  Cloud IoT Core Documentation  |  Google Cloud.” \urlhttps://cloud.google.com/iot/docs/how-tos/mqtt-bridge#mqtt_server.&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;</content><author><name>fatih</name></author><category term="iot" /><category term="security" /><summary type="html">Securing low power IoT devices is very resource consuming. Do we need lighter primitives?</summary></entry><entry><title type="html">How to expect the unexpected</title><link href="https://blog.fatihbakir.net/2019/05/14/unexpected.html" rel="alternate" type="text/html" title="How to expect the unexpected" /><published>2019-05-14T00:00:00-07:00</published><updated>2019-05-14T00:00:00-07:00</updated><id>https://blog.fatihbakir.net/2019/05/14/unexpected</id><content type="html" xml:base="https://blog.fatihbakir.net/2019/05/14/unexpected.html">&lt;p&gt;Although C++ has a sophisticated error handling mechanism, ie exceptions, in embedded domains they are
usually disabled due to code size spent on jump table sizes with zero overhead exceptions or the runtime
overhead in other implementations. And in projects they are enabled, their use is usually frowned upon
due to the extreme costs of throwing an exception. It’s said that you should only throw an exception
in exceptional situations, though what constitutes an exceptional situation is not well defined.&lt;/p&gt;

&lt;p&gt;Anyway, due to these reasons, the C++ community has been in search of better error handling mechanisms.
While some &lt;a class=&quot;citation&quot; href=&quot;#herbceptions&quot;&gt;[1]&lt;/a&gt; are working on fixing exceptions with core language changes, some 
&lt;a class=&quot;citation&quot; href=&quot;#boostoutcome&quot;&gt;[2]&lt;/a&gt;, &lt;a class=&quot;citation&quot; href=&quot;#expected&quot;&gt;[3]&lt;/a&gt; are working on going a different, purely library based route.&lt;/p&gt;

&lt;p&gt;I personally like and use the expected objects as the return value from fallible functions. They encapsulate
the reason for the failure if something fails, so it’s better for the caller to get such information.&lt;/p&gt;

&lt;p&gt;However, there are a few pain points I have with it:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;They don’t easily compose&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If you have a function &lt;code class=&quot;highlighter-rouge&quot;&gt;expected&amp;lt;T, foo_errors&amp;gt; foo();&lt;/code&gt; and another &lt;code class=&quot;highlighter-rouge&quot;&gt;expected&amp;lt;T, bar_errors&amp;gt; bar();&lt;/code&gt;, which
calls &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;, it’s difficult to return it’s error value directly. Either you have to put all the values of
&lt;code class=&quot;highlighter-rouge&quot;&gt;foo_errors&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;bar_errors&lt;/code&gt;, or simply discard that and put a single &lt;code class=&quot;highlighter-rouge&quot;&gt;foo_failed&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;bar_errors&lt;/code&gt;. That’s
not really nice. You could change bar to be &lt;code class=&quot;highlighter-rouge&quot;&gt;expected&amp;lt;T, variant&amp;lt;foo_errors, bar_errors&amp;gt;&amp;gt;&lt;/code&gt; to make a better
interface, but it just goes deeper and deeper and still doesn’t compose automatically, you have to keep
track of the error types of every callee in a function.&lt;/p&gt;

&lt;p&gt;However, I can live with this.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;They don’t work in embedded&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unexpected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What does this program do?&lt;/p&gt;

&lt;p&gt;According to the proposal, and the reference implementation, it throws an exception. But the reason I’ve
picked this library is it was kind of promising to replace exceptions for me. Though the purpose of the paper
isn’t exactly that, I think we might actually solve this.&lt;/p&gt;

&lt;p&gt;The main problem it’s useless in embedded is that the &lt;code class=&quot;highlighter-rouge&quot;&gt;expected::value&lt;/code&gt; function, which promises to return
the internal value unconditionally. We want a tighter interface. For it to be usable in a mission critical
domain, it has to enforce the error checking at compile time.&lt;/p&gt;

&lt;h2 id=&quot;tosexpected&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tos::expected&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;This is a type we provide in our embedded operating system. It simply privately inherits from &lt;code class=&quot;highlighter-rouge&quot;&gt;tl::expected&lt;/code&gt;
and exposes a much more restricted interface. In short, there’s only &lt;em&gt;safe&lt;/em&gt; functions for accessing the 
internal value:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_or&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;operator std::optional&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;force_get&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The first one is simple, you call it with an expected, and pass 2 lambdas, one for when there’s a value, and
one for when there’s an error:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fallible_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It’s statically enforced that you can’t try to access the internal value if there’s none.&lt;/p&gt;

&lt;p&gt;The second one is simply a refinement over &lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt;, it basically tries to get the internal value, and if
there’s no value, it returns another value passed to the function:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fallible_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;705&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This doesn’t let you handle the error explicitly, but you still can’t access a non-existent value, enforced
at compile time.&lt;/p&gt;

&lt;p&gt;The third one is a little convenience conversion operator for times when you don’t care about the error at all
and just want to get a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::optional&lt;/code&gt;. The operator is explicit, so you don’t get any unexpected (see the pun?)
conversions. However, this is a bit dangerous as &lt;code class=&quot;highlighter-rouge&quot;&gt;std::optional&lt;/code&gt; doesn’t enforce checking the error at compile
time as we do.&lt;/p&gt;

&lt;p&gt;Finally, &lt;code class=&quot;highlighter-rouge&quot;&gt;force_get&lt;/code&gt;. Despite it’s name, it doesn’t really force anything. When you call this function, if there’s
no value in the expected object, the kernel panics. So, no undefined behavior, but still not really a desirable
thing to have in your systems.&lt;/p&gt;

&lt;p&gt;However, the use case is definitely not calling it on random &lt;code class=&quot;highlighter-rouge&quot;&gt;expected&lt;/code&gt;s. The use case is to call this function
only when you &lt;em&gt;know&lt;/em&gt; there’s a value in the expected:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fallible_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;force_get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since you check the expected before accessing &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt;, there’s no risk of a kernel panic.&lt;/p&gt;

&lt;p&gt;However, as you might’ve guessed, we can’t enforce this at compile time.&lt;/p&gt;

&lt;p&gt;Or can we?&lt;/p&gt;

&lt;p&gt;Although it’s not completely standard, there’s a hack we use to enforce this. We can’t really enforce this
at the compiler since the types don’t care about the control flow.&lt;/p&gt;

&lt;p&gt;However, using some tricks, we can actually detect whether you’ve missed to check an error. The trick is to
always inline the &lt;code class=&quot;highlighter-rouge&quot;&gt;force_get&lt;/code&gt; call, and have a special hook to call when it fails:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALWAYS_INLINE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;force_get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExpectedT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_internal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;tos_force_get_failed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expected::m_internal&lt;/code&gt; is a &lt;code class=&quot;highlighter-rouge&quot;&gt;tl::expected&lt;/code&gt;. As you can see, we have an always inline function that repeats
the check we’re supposed to do in the scope we should call it. This means that the compiler will see that
we’re doing a redundant check, and drop the if that’s coming from &lt;code class=&quot;highlighter-rouge&quot;&gt;force_get&lt;/code&gt;. Since it drops the if, the
branch that calls &lt;code class=&quot;highlighter-rouge&quot;&gt;tos_force_get_failed&lt;/code&gt; disappears completely. Therefore, we don’t get any runtime overhead
for doing this.&lt;/p&gt;

&lt;p&gt;We also use link time size optimizations such as garbage collecting unused symbols. In a program that always
checks whether there’s a value before calling &lt;code class=&quot;highlighter-rouge&quot;&gt;force_get&lt;/code&gt;, the &lt;code class=&quot;highlighter-rouge&quot;&gt;tos_force_get_failed&lt;/code&gt; symbol must be unused,
and thus should not appear in the final binary. Therefore, with a single &lt;code class=&quot;highlighter-rouge&quot;&gt;nm | grep tos_force_get_failed&lt;/code&gt;,
we can determine whether we’ve called &lt;code class=&quot;highlighter-rouge&quot;&gt;force_get&lt;/code&gt; on an unknown expected.&lt;/p&gt;

&lt;p&gt;Obviously, this won’t give you a lot of information regarding where you’ve forgot to check the expected, but
it’s better to realize you’ve forgotten to check it before programming the device rather than after crashing
at runtime.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul class=&quot;bibliography&quot;&gt;&lt;li&gt;&lt;span id=&quot;herbceptions&quot;&gt;[1]“ACCU talk video posted – Sutter’s Mill.” \urlhttps://herbsutter.com/2019/04/28/accu-talk-video-posted/.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;boostoutcome&quot;&gt;[2]“Outcome documentation.” \urlhttps://ned14.github.io/outcome/.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;expected&quot;&gt;[3]J. F. B. Vicente J. Botet Escribá, “Utility class to represent expected object.” \urlhttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r3.pdf.&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;</content><author><name>fatih</name></author><category term="c++" /><category term="embedded" /><category term="os" /><summary type="html">Can we deal with bad expected objects in embedded systems?</summary></entry><entry><title type="html">Please do not disturb</title><link href="https://blog.fatihbakir.net/2019/05/13/dont-disturb.html" rel="alternate" type="text/html" title="Please do not disturb" /><published>2019-05-13T00:00:00-07:00</published><updated>2019-05-13T00:00:00-07:00</updated><id>https://blog.fatihbakir.net/2019/05/13/dont-disturb</id><content type="html" xml:base="https://blog.fatihbakir.net/2019/05/13/dont-disturb.html">&lt;p&gt;Just like regular operating systems, embedded OSes have multiple responsibilities. First, they have to execute user programs. And second, they need to manage IO. IO usually doesn’t execute instantaneously, it takes some time. Some time we’d rather spend executing user code rather than just waiting for IO to complete. The external devices are usually smart enough to run on their own and just &lt;em&gt;interrupt&lt;/em&gt; the compiler when they need something. So, upon an IO request by a thread, we just initiate an IO operation on the hardware and block the thread until IO finishes. If there are other threads to execute, we’ll just do that.&lt;/p&gt;

&lt;p&gt;However, interrupts act like preemptive threads. Meaning, at any point in a program, we might get preempted by an interrupt service routine. Although ISRs and the normal thread world should be as decoupled as possible, at some point, some data will be shared between them. This easily leads to difficult to track down race conditions.&lt;/p&gt;

&lt;p&gt;The most obvious resource ISRs and the &lt;em&gt;normal&lt;/em&gt; world share is the thread queues. There’s a queue of runnable threads in a system that the scheduler uses, called the run queue. When a thread is created, it’s placed on that queue so it can start executing. When a thread starts executing, it’s taken off that list. When a thread blocks, it’s placed in the wait queue of whatever it’s blocking on. The threads in a block queue is usually placed back into the run queue by an interrupt service routine. For instance, when you’re sleeping for 5 seconds, you’re waiting for an ISR to wake you up by placing you back to the run queue eventually.&lt;/p&gt;

&lt;p&gt;Now, imagine a moment where a task starts attempts to block on a resource, called &lt;script type=&quot;math/tex&quot;&gt;R_x&lt;/script&gt; at time &lt;script type=&quot;math/tex&quot;&gt;T_1&lt;/script&gt; and it takes &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; time to finish placing the thread in the block queue and suspend it. There exists an ISR &lt;script type=&quot;math/tex&quot;&gt;I_x&lt;/script&gt; that unblocks threads waiting on &lt;script type=&quot;math/tex&quot;&gt;R_x&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/img1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It is possible that &lt;script type=&quot;math/tex&quot;&gt;I_x&lt;/script&gt; will be serviced during &lt;script type=&quot;math/tex&quot;&gt;[T_1, T_1 + t)&lt;/script&gt;. In that case, we’ll have a nice race condition and quickly go into the undefined behavior land.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/img2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To avoid such a problem, we disable interrupts before placing a thread in the wait queue of a resource and enable them back right after placing it in the queue.&lt;/p&gt;

&lt;h2 id=&quot;death-by-a-thousand-interrupt-disables&quot;&gt;Death by a thousand interrupt disables&lt;/h2&gt;

&lt;p&gt;That solves our little problem. However, it turns out that you don’t want to always block unconditionally. You want to check if a condition has been satisfied and if not, block until it does. This is exactly what a &lt;em&gt;semaphore&lt;/em&gt; represents:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes_received&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ring_buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bytes_received&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;down&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop_front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;read_byte&lt;/code&gt; is called, we don’t necessarily want to block. If there already exists some bytes in the buffer, we want to take the first one. If there’s none, we want to wait until some arrives.&lt;/p&gt;

&lt;p&gt;Now, to check how many bytes there are in the buffer, we have to read a shared integer. To do so, we must disable interrupts. This is in the &lt;code class=&quot;highlighter-rouge&quot;&gt;down&lt;/code&gt; function of semaphores, and looks like this basically:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;down&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;int_guard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	    &lt;span class=&quot;n&quot;&gt;m_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now, we disable interrupts once in the &lt;code class=&quot;highlighter-rouge&quot;&gt;int_guard&lt;/code&gt;. Then, we call &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt; on the &lt;code class=&quot;highlighter-rouge&quot;&gt;m_wait&lt;/code&gt; object, which is of type &lt;code class=&quot;highlighter-rouge&quot;&gt;waitable&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;waitable&lt;/code&gt;s are basically just a wrapper around a queue of threads that present an easier interface, like a &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt; function rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;emplace_back(current_thread)&lt;/code&gt; and suspend.&lt;/p&gt;

&lt;p&gt;But, as we talked about previously, blocking also needs to disable interrupts. So, it’ll construct another &lt;code class=&quot;highlighter-rouge&quot;&gt;int_guard&lt;/code&gt; object before placing the thread into the wait queue.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/img3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After that, we have to suspend the current thread, which means switching context to another thread. However, context switching is another potentially dangerous function. So interrupts must be disabled during that time as well.&lt;/p&gt;

&lt;p&gt;So, for just a &lt;code class=&quot;highlighter-rouge&quot;&gt;semaphore::down&lt;/code&gt; call, we have to disable interrupts 3 times. This is called the abstraction penalty. Since we obviously don’t want to pay this cost, we’ll cut some corners in terms of safety. For instance, the last call, &lt;code class=&quot;highlighter-rouge&quot;&gt;suspend_self&lt;/code&gt; will have a precondition:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**  
 * Gives control of the CPU back to the scheduler, 
 * suspending * the current thread.  
 * If the interrupts are not disabled when this function 
 * is called, the behaviour is undefined 
 */&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suspend_self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  
 &lt;span class=&quot;c1&quot;&gt;// pre-condition: interrupts must be disabled&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So, we’ve just traded performance for safety. Now, our code has UB if we attempt to suspend the current thread without disabling interrupts. Now, this function isn’t meant to be called directly, so the dangers aren’t that high, but still, there’s some unsafety and we still call the interrupt disable/enable pair twice.&lt;/p&gt;

&lt;p&gt;You might be wondering how we can actually disable and enable interrupts twice. The hardware doesn’t know how many times you’ve disabled interrupts after all. There are 2 ways you can go about that: either store the current interrupt information in the &lt;code class=&quot;highlighter-rouge&quot;&gt;int_guard&lt;/code&gt; object and restore it upon enabling, or count how many times we’ve disabled interrupts, and only enable them back when the counter reaches 0. The former solution is more &lt;em&gt;pure&lt;/em&gt;, but the latter has $O(1)$ storage cost, so that’s the way we go about it. However, either method imposes some non-trivial runtime overhead, so I’d rather not to that twice.&lt;/p&gt;

&lt;p&gt;Ideally, I could mark functions as &lt;em&gt;no interrupts&lt;/em&gt; like we do with &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;noexcept&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waitable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no_int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suspend_self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no_int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And the compiler just statically checks whether I’m calling from a non-interruptible context. However, this doesn’t scale as I can just come up with more stuff that fits this criteria.&lt;/p&gt;

&lt;p&gt;The solution is to use the type system. We’ll introduce a new empty type, and make &lt;code class=&quot;highlighter-rouge&quot;&gt;int_guard&lt;/code&gt; inherit from that:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no_int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int_guard&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no_int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And we’ll change any function that expects there to be no interrupts to take a const reference to a &lt;code class=&quot;highlighter-rouge&quot;&gt;no_int&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waitable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no_int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suspend_self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no_int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, the C++ compiler will just prevent anyone from calling these functions unless they have an &lt;code class=&quot;highlighter-rouge&quot;&gt;int_guard&lt;/code&gt; instance lying around.&lt;/p&gt;

&lt;p&gt;And &lt;code class=&quot;highlighter-rouge&quot;&gt;waitable::wait&lt;/code&gt; just passes it’s reference to &lt;code class=&quot;highlighter-rouge&quot;&gt;suspend_self&lt;/code&gt;, so it’s easy to carry this information down the call stack.&lt;/p&gt;

&lt;p&gt;So, &lt;code class=&quot;highlighter-rouge&quot;&gt;semaphore::down&lt;/code&gt; will just look like this:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;down&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;int_guard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	    &lt;span class=&quot;n&quot;&gt;m_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If you aren’t familiar with C++’s inheritance mechanism, this doesn’t add any overhead to functions the compiler inlines. If it can’t inline, it’s equivalent to passing a single reference.&lt;/p&gt;

&lt;p&gt;Awesome! Now, you might say they can just construct a &lt;code class=&quot;highlighter-rouge&quot;&gt;no_int&lt;/code&gt; instance and pass that as well. Well, they shouldn’t. But we have the technology to solve that as well:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no_int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;no_int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;int_guard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This way, short of modifying the &lt;code class=&quot;highlighter-rouge&quot;&gt;no_int&lt;/code&gt; type, the users of the library &lt;em&gt;must&lt;/em&gt; use an &lt;code class=&quot;highlighter-rouge&quot;&gt;int_guard&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;theres-another&quot;&gt;There’s another&lt;/h2&gt;

&lt;p&gt;You might be wondering why we’re going to unnecessary lengths and not using a &lt;code class=&quot;highlighter-rouge&quot;&gt;const int_guard&amp;amp;&lt;/code&gt;. The answer is that, there’s another way of disabling interrupts in a system, and the other one is if we are already in an interrupt context (that means we’re already servicing an interrupt)!&lt;/p&gt;

&lt;p&gt;To model this, we add another type:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;detail&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int_ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no_int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When we enter an ISR, we’ll construct an &lt;code class=&quot;highlighter-rouge&quot;&gt;int_ctx&lt;/code&gt;, and pass that to the functions that expect interrupts to be turned off.&lt;/p&gt;</content><author><name>fatih</name></author><category term="c++" /><category term="embedded" /><category term="os" /><summary type="html">Ensuring atomic behaviour without wasting time</summary></entry></feed>