<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>Please do not disturb | Fatih’s blog</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Please do not disturb" />
<meta name="author" content="fatih" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Ensuring atomic behaviour without wasting time" />
<meta property="og:description" content="Ensuring atomic behaviour without wasting time" />
<link rel="canonical" href="https://blog.fatihbakir.net/2019/05/13/dont-disturb.html" />
<meta property="og:url" content="https://blog.fatihbakir.net/2019/05/13/dont-disturb.html" />
<meta property="og:site_name" content="Fatih’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-13T00:00:00-07:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"https://blog.fatihbakir.net/2019/05/13/dont-disturb.html","headline":"Please do not disturb","dateModified":"2019-05-13T00:00:00-07:00","datePublished":"2019-05-13T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.fatihbakir.net/2019/05/13/dont-disturb.html"},"author":{"@type":"Person","name":"fatih"},"description":"Ensuring atomic behaviour without wasting time","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://blog.fatihbakir.net/feed.xml" title="Fatih's blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Fatih&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Please do not disturb</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-05-13T00:00:00-07:00" itemprop="datePublished">May 13, 2019
      </time><!--<span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">fatih</span></span>-->
          •



  <img src="https://gravatar.com/avatar/35df13054d8d9aef497eaba29e97d087" class="onbellek-post-author-image"/>



  <span class="onbellek-post-author-name"> Fatih Bakir </span>

</p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Just like regular operating systems, embedded OSes have multiple responsibilities. First, they have to execute user programs. And second, they need to manage IO. IO usually doesn’t execute instantaneously, it takes some time. Some time we’d rather spend executing user code rather than just waiting for IO to complete. The external devices are usually smart enough to run on their own and just <em>interrupt</em> the compiler when they need something. So, upon an IO request by a thread, we just initiate an IO operation on the hardware and block the thread until IO finishes. If there are other threads to execute, we’ll just do that.</p>

<p>However, interrupts act like preemptive threads. Meaning, at any point in a program, we might get preempted by an interrupt service routine. Although ISRs and the normal thread world should be as decoupled as possible, at some point, some data will be shared between them. This easily leads to difficult to track down race conditions.</p>

<p>The most obvious resource ISRs and the <em>normal</em> world share is the thread queues. There’s a queue of runnable threads in a system that the scheduler uses, called the run queue. When a thread is created, it’s placed on that queue so it can start executing. When a thread starts executing, it’s taken off that list. When a thread blocks, it’s placed in the wait queue of whatever it’s blocking on. The threads in a block queue is usually placed back into the run queue by an interrupt service routine. For instance, when you’re sleeping for 5 seconds, you’re waiting for an ISR to wake you up by placing you back to the run queue eventually.</p>

<p>Now, imagine a moment where a task starts attempts to block on a resource, called <script type="math/tex">R_x</script> at time <script type="math/tex">T_1</script> and it takes <script type="math/tex">t</script> time to finish placing the thread in the block queue and suspend it. There exists an ISR <script type="math/tex">I_x</script> that unblocks threads waiting on <script type="math/tex">R_x</script>.</p>

<p><img src="/assets/img/img1.png" alt="" /></p>

<p>It is possible that <script type="math/tex">I_x</script> will be serviced during <script type="math/tex">[T_1, T_1 + t)</script>. In that case, we’ll have a nice race condition and quickly go into the undefined behavior land.</p>

<p><img src="/assets/img/img2.png" alt="" /></p>

<p>To avoid such a problem, we disable interrupts before placing a thread in the wait queue of a resource and enable them back right after placing it in the queue.</p>

<h2 id="death-by-a-thousand-interrupt-disables">Death by a thousand interrupt disables</h2>

<p>That solves our little problem. However, it turns out that you don’t want to always block unconditionally. You want to check if a condition has been satisfied and if not, block until it does. This is exactly what a <em>semaphore</em> represents:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">semaphore</span> <span class="n">bytes_received</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="n">ring_buf</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">bytes</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">read_byte</span><span class="p">(){</span>
	<span class="n">bytes_received</span><span class="p">.</span><span class="n">down</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
	<span class="n">bytes</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>When <code class="highlighter-rouge">read_byte</code> is called, we don’t necessarily want to block. If there already exists some bytes in the buffer, we want to take the first one. If there’s none, we want to wait until some arrives.</p>

<p>Now, to check how many bytes there are in the buffer, we have to read a shared integer. To do so, we must disable interrupts. This is in the <code class="highlighter-rouge">down</code> function of semaphores, and looks like this basically:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">semaphore</span><span class="o">::</span><span class="n">down</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">int_guard</span> <span class="n">ig</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
	    <span class="n">m_wait</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Now, we disable interrupts once in the <code class="highlighter-rouge">int_guard</code>. Then, we call <code class="highlighter-rouge">wait</code> on the <code class="highlighter-rouge">m_wait</code> object, which is of type <code class="highlighter-rouge">waitable</code>. <code class="highlighter-rouge">waitable</code>s are basically just a wrapper around a queue of threads that present an easier interface, like a <code class="highlighter-rouge">wait</code> function rather than <code class="highlighter-rouge">emplace_back(current_thread)</code> and suspend.</p>

<p>But, as we talked about previously, blocking also needs to disable interrupts. So, it’ll construct another <code class="highlighter-rouge">int_guard</code> object before placing the thread into the wait queue.</p>

<p><img src="/assets/img/img3.png" alt="" /></p>

<p>After that, we have to suspend the current thread, which means switching context to another thread. However, context switching is another potentially dangerous function. So interrupts must be disabled during that time as well.</p>

<p>So, for just a <code class="highlighter-rouge">semaphore::down</code> call, we have to disable interrupts 3 times. This is called the abstraction penalty. Since we obviously don’t want to pay this cost, we’ll cut some corners in terms of safety. For instance, the last call, <code class="highlighter-rouge">suspend_self</code> will have a precondition:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**  
 * Gives control of the CPU back to the scheduler, 
 * suspending * the current thread.  
 * If the interrupts are not disabled when this function 
 * is called, the behaviour is undefined 
 */</span>
 <span class="kt">void</span> <span class="n">suspend_self</span><span class="p">();</span>  
 <span class="c1">// pre-condition: interrupts must be disabled</span>
</code></pre></div></div>
<p>So, we’ve just traded performance for safety. Now, our code has UB if we attempt to suspend the current thread without disabling interrupts. Now, this function isn’t meant to be called directly, so the dangers aren’t that high, but still, there’s some unsafety and we still call the interrupt disable/enable pair twice.</p>

<p>You might be wondering how we can actually disable and enable interrupts twice. The hardware doesn’t know how many times you’ve disabled interrupts after all. There are 2 ways you can go about that: either store the current interrupt information in the <code class="highlighter-rouge">int_guard</code> object and restore it upon enabling, or count how many times we’ve disabled interrupts, and only enable them back when the counter reaches 0. The former solution is more <em>pure</em>, but the latter has $O(1)$ storage cost, so that’s the way we go about it. However, either method imposes some non-trivial runtime overhead, so I’d rather not to that twice.</p>

<p>Ideally, I could mark functions as <em>no interrupts</em> like we do with <code class="highlighter-rouge">const</code> or <code class="highlighter-rouge">noexcept</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">waitable</span><span class="o">::</span><span class="n">wait</span><span class="p">()</span> <span class="n">no_int</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">suspend_self</span><span class="p">()</span> <span class="n">no_int</span><span class="p">;</span>
</code></pre></div></div>

<p>And the compiler just statically checks whether I’m calling from a non-interruptible context. However, this doesn’t scale as I can just come up with more stuff that fits this criteria.</p>

<p>The solution is to use the type system. We’ll introduce a new empty type, and make <code class="highlighter-rouge">int_guard</code> inherit from that:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">no_int</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="n">int_guard</span> <span class="o">:</span> <span class="n">no_int</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</code></pre></div></div>

<p>And we’ll change any function that expects there to be no interrupts to take a const reference to a <code class="highlighter-rouge">no_int</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">waitable</span><span class="o">::</span><span class="n">wait</span><span class="p">(</span><span class="k">const</span> <span class="n">no_int</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">suspend_self</span><span class="p">(</span><span class="k">const</span> <span class="n">no_int</span><span class="o">&amp;</span><span class="p">);</span>
</code></pre></div></div>

<p>Now, the C++ compiler will just prevent anyone from calling these functions unless they have an <code class="highlighter-rouge">int_guard</code> instance lying around.</p>

<p>And <code class="highlighter-rouge">waitable::wait</code> just passes it’s reference to <code class="highlighter-rouge">suspend_self</code>, so it’s easy to carry this information down the call stack.</p>

<p>So, <code class="highlighter-rouge">semaphore::down</code> will just look like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">semaphore</span><span class="o">::</span><span class="n">down</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">int_guard</span> <span class="n">ig</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
	    <span class="n">m_wait</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">ig</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>If you aren’t familiar with C++’s inheritance mechanism, this doesn’t add any overhead to functions the compiler inlines. If it can’t inline, it’s equivalent to passing a single reference.</p>

<p>Awesome! Now, you might say they can just construct a <code class="highlighter-rouge">no_int</code> instance and pass that as well. Well, they shouldn’t. But we have the technology to solve that as well:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">no_int</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
	<span class="n">no_int</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="k">friend</span> <span class="k">class</span> <span class="nc">int_guard</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>This way, short of modifying the <code class="highlighter-rouge">no_int</code> type, the users of the library <em>must</em> use an <code class="highlighter-rouge">int_guard</code>.</p>

<h2 id="theres-another">There’s another</h2>

<p>You might be wondering why we’re going to unnecessary lengths and not using a <code class="highlighter-rouge">const int_guard&amp;</code>. The answer is that, there’s another way of disabling interrupts in a system, and the other one is if we are already in an interrupt context (that means we’re already servicing an interrupt)!</p>

<p>To model this, we add another type:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">int_ctx</span> <span class="o">:</span> <span class="n">no_int</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When we enter an ISR, we’ll construct an <code class="highlighter-rouge">int_ctx</code>, and pass that to the functions that expect interrupts to be turned off.</p>

  </div><a class="u-url" href="/2019/05/13/dont-disturb.html" hidden></a>
</article>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Fatih&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Fatih&#39;s blog</li><li><a class="u-email" href="mailto:mfatihbakir@gmail.com">mfatihbakir@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/FatihBAKIR"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FatihBAKIR</span></a></li><li><a href="https://www.twitter.com/mfatihbakir"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">mfatihbakir</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Blog </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
