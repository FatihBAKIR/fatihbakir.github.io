<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>How to expect the unexpected | Fatih’s blog</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="How to expect the unexpected" />
<meta name="author" content="fatih" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Can we deal with bad expected objects in embedded systems?" />
<meta property="og:description" content="Can we deal with bad expected objects in embedded systems?" />
<link rel="canonical" href="https://blog.fatihbakir.net/2019/05/14/unexpected.html" />
<meta property="og:url" content="https://blog.fatihbakir.net/2019/05/14/unexpected.html" />
<meta property="og:site_name" content="Fatih’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-14T00:00:00-07:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"https://blog.fatihbakir.net/2019/05/14/unexpected.html","headline":"How to expect the unexpected","dateModified":"2019-05-14T00:00:00-07:00","datePublished":"2019-05-14T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.fatihbakir.net/2019/05/14/unexpected.html"},"author":{"@type":"Person","name":"fatih"},"description":"Can we deal with bad expected objects in embedded systems?","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://blog.fatihbakir.net/feed.xml" title="Fatih's blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Fatih&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">How to expect the unexpected</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-05-14T00:00:00-07:00" itemprop="datePublished">May 14, 2019
      </time><!--<span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">fatih</span></span>-->
          •



  <img src="https://gravatar.com/avatar/35df13054d8d9aef497eaba29e97d087" class="onbellek-post-author-image"/>



  <span class="onbellek-post-author-name"> Fatih Bakir </span>

</p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Although C++ has a sophisticated error handling mechanism, ie exceptions, in embedded domains they are
usually disabled due to code size spent on jump table sizes with zero overhead exceptions or the runtime
overhead in other implementations. And in projects they are enabled, their use is usually frowned upon
due to the extreme costs of throwing an exception. It’s said that you should only throw an exception
in exceptional situations, though what constitutes an exceptional situation is not well defined.</p>

<p>Anyway, due to these reasons, the C++ community has been in search of better error handling mechanisms.
While some <a class="citation" href="#herbceptions">[1]</a> are working on fixing exceptions with core language changes, some 
<a class="citation" href="#boostoutcome">[2]</a>, <a class="citation" href="#expected">[3]</a> are working on going a different, purely library based route.</p>

<p>I personally like and use the expected objects as the return value from fallible functions. They encapsulate
the reason for the failure if something fails, so it’s better for the caller to get such information.</p>

<p>However, there are a few pain points I have with it:</p>

<p><strong>They don’t easily compose</strong></p>

<p>If you have a function <code class="highlighter-rouge">expected&lt;T, foo_errors&gt; foo();</code> and another <code class="highlighter-rouge">expected&lt;T, bar_errors&gt; bar();</code>, which
calls <code class="highlighter-rouge">foo</code>, it’s difficult to return it’s error value directly. Either you have to put all the values of
<code class="highlighter-rouge">foo_errors</code> to <code class="highlighter-rouge">bar_errors</code>, or simply discard that and put a single <code class="highlighter-rouge">foo_failed</code> in <code class="highlighter-rouge">bar_errors</code>. That’s
not really nice. You could change bar to be <code class="highlighter-rouge">expected&lt;T, variant&lt;foo_errors, bar_errors&gt;&gt;</code> to make a better
interface, but it just goes deeper and deeper and still doesn’t compose automatically, you have to keep
track of the error types of every callee in a function.</p>

<p>However, I can live with this.</p>

<p><strong>They don’t work in embedded</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">expected</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">unexpected</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="p">}</span>

<span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
</code></pre></div></div>

<p>What does this program do?</p>

<p>According to the proposal, and the reference implementation, it throws an exception. But the reason I’ve
picked this library is it was kind of promising to replace exceptions for me. Though the purpose of the paper
isn’t exactly that, I think we might actually solve this.</p>

<p>The main problem it’s useless in embedded is that the <code class="highlighter-rouge">expected::value</code> function, which promises to return
the internal value unconditionally. We want a tighter interface. For it to be usable in a mission critical
domain, it has to enforce the error checking at compile time.</p>

<h2 id="tosexpected"><code class="highlighter-rouge">tos::expected</code></h2>

<p>This is a type we provide in our embedded operating system. It simply privately inherits from <code class="highlighter-rouge">tl::expected</code>
and exposes a much more restricted interface. In short, there’s only <em>safe</em> functions for accessing the 
internal value:</p>

<ol>
  <li><code class="highlighter-rouge">with</code></li>
  <li><code class="highlighter-rouge">get_or</code></li>
  <li><code class="highlighter-rouge">operator std::optional&lt;T&gt;</code></li>
  <li><code class="highlighter-rouge">force_get</code></li>
</ol>

<p>The first one is simple, you call it with an expected, and pass 2 lambdas, one for when there’s a value, and
one for when there’s an error:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">with</span><span class="p">(</span><span class="n">fallible_func</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="n">use</span> <span class="n">val</span> <span class="p">...</span>
<span class="p">},</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">err</span><span class="p">){</span>
    <span class="p">...</span> <span class="n">use</span> <span class="n">err</span> <span class="p">...</span>
<span class="p">});</span>
</code></pre></div></div>

<p>It’s statically enforced that you can’t try to access the internal value if there’s none.</p>

<p>The second one is simply a refinement over <code class="highlighter-rouge">with</code>, it basically tries to get the internal value, and if
there’s no value, it returns another value passed to the function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="n">get_or</span><span class="p">(</span><span class="n">fallible_func</span><span class="p">(),</span> <span class="mi">705</span><span class="p">);</span>
</code></pre></div></div>

<p>This doesn’t let you handle the error explicitly, but you still can’t access a non-existent value, enforced
at compile time.</p>

<p>The third one is a little convenience conversion operator for times when you don’t care about the error at all
and just want to get a <code class="highlighter-rouge">std::optional</code>. The operator is explicit, so you don’t get any unexpected (see the pun?)
conversions. However, this is a bit dangerous as <code class="highlighter-rouge">std::optional</code> doesn’t enforce checking the error at compile
time as we do.</p>

<p>Finally, <code class="highlighter-rouge">force_get</code>. Despite it’s name, it doesn’t really force anything. When you call this function, if there’s
no value in the expected object, the kernel panics. So, no undefined behavior, but still not really a desirable
thing to have in your systems.</p>

<p>However, the use case is definitely not calling it on random <code class="highlighter-rouge">expected</code>s. The use case is to call this function
only when you <em>know</em> there’s a value in the expected:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">fallible_func</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

<span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">force_get</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
</code></pre></div></div>

<p>Since you check the expected before accessing <code class="highlighter-rouge">e</code>, there’s no risk of a kernel panic.</p>

<p>However, as you might’ve guessed, we can’t enforce this at compile time.</p>

<p>Or can we?</p>

<p>Although it’s not completely standard, there’s a hack we use to enforce this. We can’t really enforce this
at the compiler since the types don’t care about the control flow.</p>

<p>However, using some tricks, we can actually detect whether you’ve missed to check an error. The trick is to
always inline the <code class="highlighter-rouge">force_get</code> call, and have a special hook to call when it fails:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">ALWAYS_INLINE</span> <span class="n">force_get</span><span class="p">(</span><span class="n">ExpectedT</span><span class="o">&amp;&amp;</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">e</span><span class="p">.</span><span class="n">m_internal</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">tos_force_get_failed</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">expected::m_internal</code> is a <code class="highlighter-rouge">tl::expected</code>. As you can see, we have an always inline function that repeats
the check we’re supposed to do in the scope we should call it. This means that the compiler will see that
we’re doing a redundant check, and drop the if that’s coming from <code class="highlighter-rouge">force_get</code>. Since it drops the if, the
branch that calls <code class="highlighter-rouge">tos_force_get_failed</code> disappears completely. Therefore, we don’t get any runtime overhead
for doing this.</p>

<p>We also use link time size optimizations such as garbage collecting unused symbols. In a program that always
checks whether there’s a value before calling <code class="highlighter-rouge">force_get</code>, the <code class="highlighter-rouge">tos_force_get_failed</code> symbol must be unused,
and thus should not appear in the final binary. Therefore, with a single <code class="highlighter-rouge">nm | grep tos_force_get_failed</code>,
we can determine whether we’ve called <code class="highlighter-rouge">force_get</code> on an unknown expected.</p>

<p>Obviously, this won’t give you a lot of information regarding where you’ve forgot to check the expected, but
it’s better to realize you’ve forgotten to check it before programming the device rather than after crashing
at runtime.</p>

<h2 id="references">References</h2>

<ul class="bibliography"><li><span id="herbceptions">[1]“ACCU talk video posted – Sutter’s Mill.” \urlhttps://herbsutter.com/2019/04/28/accu-talk-video-posted/.</span></li>
<li><span id="boostoutcome">[2]“Outcome documentation.” \urlhttps://ned14.github.io/outcome/.</span></li>
<li><span id="expected">[3]J. F. B. Vicente J. Botet Escribá, “Utility class to represent expected object.” \urlhttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r3.pdf.</span></li></ul>

  </div><a class="u-url" href="/2019/05/14/unexpected.html" hidden></a>
</article>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Fatih&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Fatih&#39;s blog</li><li><a class="u-email" href="mailto:mfatihbakir@gmail.com">mfatihbakir@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/FatihBAKIR"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FatihBAKIR</span></a></li><li><a href="https://www.twitter.com/mfatihbakir"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">mfatihbakir</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Blog </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
